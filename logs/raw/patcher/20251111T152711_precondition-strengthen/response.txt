*** Begin Patch
*** Update File: contracts/Router.sol
@@
-interface IERC20 {
+interface IERC20 {
-    function transferFrom(address from, address to, uint256 amount) external returns (bool);
-    function transfer(address to, uint256 amount) external returns (bool);
+    function transferFrom(address from, address to, uint256 amount) external returns (bool);
+    function transfer(address to, uint256 amount) external returns (bool);
+    function balanceOf(address account) external view returns (uint256);
 }
 
 contract Router {
     IERC20 public tokenIn;
     IERC20 public tokenOut;
 
@@
-    function swap(uint256 amountIn, uint256 minOut) external returns (uint256 amountOut) {
+    function swap(uint256 amountIn, uint256 minOut) external returns (uint256 amountOut) {
         require(amountIn > 0, "zero-in");
 
         // compute first so we can check minOut on the actual amountOut
         amountOut = getQuote(amountIn);
 
         // **invariant**: enforce userâ€™s minimum acceptable output
         require(amountOut >= minOut, "slippage");
 
-        // effects + interactions (simplified)
-        tokenIn.transferFrom(msg.sender, address(this), amountIn);
-        tokenOut.transfer(msg.sender, amountOut);
+        // capture pre-balance to guard against deflationary or fee-on-transfer tokens
+        uint256 balanceBefore = tokenOut.balanceOf(msg.sender);
+        // effects + interactions (simplified)
+        tokenIn.transferFrom(msg.sender, address(this), amountIn);
+        tokenOut.transfer(msg.sender, amountOut);
+        // ensure user actually received at least amountOut tokens, guarding against fee-on-transfer
+        uint256 balanceAfter = tokenOut.balanceOf(msg.sender);
+        uint256 received = balanceAfter - balanceBefore;
+        require(received >= amountOut, "slippage");
     }
 }
*** End Patch